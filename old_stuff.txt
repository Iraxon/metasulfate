record OldVal<T>(T value) {

    private String processType() {
        if (value instanceof Long) {
            return "int";
        }
        if (value instanceof Token) {
            return "'" + value;
        }
        if (value instanceof OldClosure) {
            return "function";
        }
        if (value instanceof Singleton) {
            switch ((Singleton) value) {
                case TRUE:
                    return "bool";
                case FALSE:
                    return "bool";
                default:
                    return "";
            }
        }
        if (value instanceof String) {
            if (value.equals(".")) {
                return "";
            }
            return "\"" + value + "\"";
        }
        return "Java " + value.getClass().getSimpleName();
    }

    public String toString() {
        if (value instanceof Token) {
            Token t = (Token) this.value;
            return "\'" + t.value().toString();
        }
        return value.toString() + ((processType().length() > 0) ? (" (" + processType() + ")") : "");
    }
}

record OldScope(OldScope outer, Token key, OldVal<?> value) {

    public OldScope {
        if ((key == null) != (value == null)) {
            throw new IllegalArgumentException("Nullity of name and value must be the same");
        }
    }

    public OldScope extend(Token key, OldVal<?> value) {
        return new OldScope(this, key, value);
    }

    public OldVal<?> get(Token item) {
        if (item.equals(key)) {
            return value;
        }
        if (this.outer != null) {
            return this.outer.get(item);
        }
        return null;
    }
}

class OldParser extends Traverser<Token, Val<?>> {

    public OldParser(List<Token> tokens) {
        super(tokens);
    }

    public Val<?> nextAndLast(OldScope scope)
    /*
     * Acts like eval for one argument, but throws an error if any tokens are not
     * consumed
     */
    {
        Val<?> rval = next(scope);
        if (hasNext()) {
            throw new IllegalArgumentException(
                    "A call to evalAll did not consume all tokens;\nfirst unconsumed token:\n" + grab());
        }
        return rval;
    }

    public Val<?> next(OldScope scope)
    /*
     * Returns one Val
     */
    {
        Val<?> nextVal;
        Token t;

        if (!hasNext()) {
            throw new TraverserOutOfItemsException("Parser out of tokens before complete parse");
        }
        t = grab();

        nextVal = scope.get(t);
        if (nextVal == null) {
            nextVal = evalBuiltIn(t, scope);
        }
        return checkForFunctionApplications(nextVal, scope);
    }

    public List<Val<?>> nextN(OldScope scope, int n)
    /*
     * Returns a List<Val> of length n
     */
    {
        List<Val<?>> outputList = new ArrayList<>();
        // Length check intentionally omitted; if more tokens than available are
        // demanded,
        // we want it to raise an eror.
        for (int i = 0; i < n; i++) {
            outputList.add(next(scope));
        }
        return outputList;
    }

    private Val<?> evalBuiltIn(Token t, OldScope scope) {
        Val<?> nextVal = null;
        List<Val<?>> intermediary_list;
        switch (t.type()) {
            case "id":
                switch ((String) t.value()) {
                    case "DOT":
                        // DOT should appear in the scope
                        throw new IllegalArgumentException("Attempted to use DOT where it is not defined");
                    case "LAMBDA_DOT":
                        nextVal = new Val<>(
                                new OldClosure(next(scope), scope));
                        break;
                    case "LET":
                        Val<?> nameVal = next(scope);
                        if (!(nameVal.value() instanceof Token))
                            throw new IllegalArgumentException("Non-name provided to LET");
                        Token name = (Token) nameVal.value();
                        Val<?> value = next(scope);
                        nextVal = next(scope.extend(name, value));
                        break;
                    case "PRODUCT":
                        intermediary_list = nextN(scope, 2);
                        nextVal = (new Val<>(
                                (long) intermediary_list.get(0).value()
                                        * (long) intermediary_list.get(1).value()));
                        break;
                    case "SUM":
                        intermediary_list = nextN(scope, 2);
                        nextVal = (new Val<>(
                                (long) intermediary_list.get(0).value()
                                        + (long) intermediary_list.get(1).value()));
                        break;
                    default:
                        throw new IllegalArgumentException("Undefined name:\n" + t + "\nin scope:\n" + scope);
                }
                break;
            case "lit":
                nextVal = (new Val<>(
                        t.value()));
                break;
            case "punc":
                switch ((String) t.value()) {
                    case "[":
                        nextVal = new Val<>(grabDelimitedRange(t, new Token("punc", "]")));
                        break;
                    case ".":
                        // Handled in global scope
                        break;
                    case "\'":
                        if (!hasNext()) {
                            throw new IllegalArgumentException(
                                    "Unexpected end of input after quote operator:\n" + t);
                        }
                        nextVal = new Val<>(grab());
                        break;
                    default:
                        throw new IllegalArgumentException("Unknown punctuation token:\n" + t);
                }
                break;
            default:
                throw new IllegalArgumentException("Token has unknown type:\n" + t);
        }
        if (nextVal != null) {
            return nextVal;
        }
        throw new IllegalArgumentException(
                "Undefined token (null parse):\n" + t);
    }

    private Val<?> checkForFunctionApplications(Val<?> v, OldScope scope) {
        if (!(v.value() instanceof OldClosure)) {
            if (true) {
                System.out.println("Read expr: " + v);
            }
            return v;
        }
        OldClosure closure = (OldClosure) v.value();
        Val<?> arg;
        try {
            arg = next(scope);
        } catch (NoSuchElementException e) {
            throw new TraverserOutOfItemsException("No argument provided for call to function:\n" + v);
        }

        if (arg.value() == Singleton.NO_APPLY) {
            return new Val<OldClosure>(closure);
        }
        return checkForFunctionApplications(closure.apply(arg), scope);
    }
}

record OldClosure<T>(List<Token> def, OldScope env, Class<T> returnClass) {

    public OldClosure(Val<?> ValDef, OldScope env, Class<T> returnClass) {
        this(ValtoDef(ValDef), env, returnClass);
    }

    private static List<Token> ValtoDef(Val<?> v) {
        if (v.value() instanceof List<?>) {
            List<?> list = (List<?>) v.value();
            if (list.stream().allMatch((t) -> (t instanceof Token))) {
                List<Token> castList = list.stream().map((t) -> ((Token) t)).toList();
                return castList;
            }
        }
        throw new IllegalArgumentException("Value not List<Token>:\n" + v);
    }

    public Val<T> apply(Val<?> arg) {
        OldClosure<T> closure = this;
        List<Token> def = closure.def();
        if (true) {
            System.out.println("Applying function:\n" + renderDef() + "\nto arg:\n" + arg);
        }
        OldParser subParser = new OldParser(def);
        Val<?> rVal1;
        try {
            rVal1 = subParser.nextAndLast(env.extend(new Token("DOT"), arg));
        } catch (EmptySrcException e) {
            throw new NoProvidedArgumentException(
                    "Attempted to apply function with empty definition");
        }
        if (true) {
            System.out.println("yielding:\n" + rVal1);
        }
        T value = returnClass.isInstance(rVal1) ? returnClass.cast(rVal1.value()) : null;
        if (value == null) {
            throw new IllegalArgumentException("Function did not return promised type");
        }
        return new Val<>(value);
    }

    public String renderDef() {
        String out = "[";
        for (int i = 0; i < def.size(); i++) {
            out += def.get(i).simpleName() + (i < def.size() - 1 ? " " : "]");
        }
        return out;
    }

    public String toString() {
        return "LAMBDA_DOT " + renderDef();
    }
}

record ReferenceExpression(Name name) implements Node {
    @Override
    public TerminalNode simplify(Scope scope) {
        return scope.get(name);
    }

    public String toString() {
        return this.name.toString();
    }
}

record CallExpression(Node function, Node arg) implements Node {

    @Override
    public TerminalNode simplify(Scope scope) {
        TerminalNode functionClosure1 = this.function.simplify(scope);
        Closure functionClosure2;
        try {
            functionClosure2 = (Closure) functionClosure1;
        } catch (ClassCastException e) {
            throw new TypeException("CallExpression given non-function Node as its first child:\n" + function);
        }
        return functionClosure2.apply(arg.simplify(scope));
    }

    public String toString() {
        return this.function.toString() + " " + this.arg.toString();
    }
}

class Parser extends Traverser<Token, Node> {
    private Scope currentScope = Scope.defaultScope;

    public Parser(List<Token> src) {
        super(src);
    }

    public Node next() {
        Token t = grab();
        TerminalNode rVal;
        switch (t.type()) {
            case TokenType.COMMENT:
                throw new IllegalArgumentException("Comment token passed to parser");
            case TokenType.ID:
                switch ((String) t.value()) {
                    case "LAMBDA_DOT":
                        rVal = new MesoClosure(next(), currentScope);
                    case "LET":
                        Node nameUncast = next();
                        if (!(nameUncast instanceof Name)) {
                            throw new TypeException("LET statement give non-name:\n" + nameUncast);
                        }
                        Name name = (Name) nameUncast;
                        Node value = next();
                        currentScope = currentScope.extend(name, value.simplify(currentScope));
                        rVal = next().simplify(currentScope);
                        currentScope = currentScope.outer();
                    default:
                        rVal = new Name(t);
                        break;
                }
                break;
            case TokenType.LIT:
                rVal = new Value(t.value());
                break;
            case TokenType.PUNC:
                switch ((String) t.value()) {
                    case "\'":
                        rVal = new Name(grab());
                    case ".":
                        rVal = Singleton.NO_APPLY;
                        break;
                    default:
                        throw new IllegalArgumentException("Parser does not recognize this punctuation:\n" + t);
                }
                break;
            default:
                throw new IllegalArgumentException("Token has unknown type:\n" + t);
        }
        switch (rVal.type()) {
            case TypeConstants.NAME:
                return new ReferenceExpression((Name) rVal);
            case TypeConstants.FUNCTION:
                return new CallExpression(rVal, next());
            default:
                return rVal;
        }
    }
}

class Lexer {
    private String src;
    private int cursor;

    private static final Set<Character> whitespace = new HashSet<>(
            Arrays.asList(new Character[] { ' ', '\n', '\t' }));

    private static final Set<Character> punctuation = new HashSet<>(
            Arrays.asList(new Character[] {
                    '[', ']',
                    '(', ')',
                    '{', '}',
                    ':', ';',
                    '\'', '\"',
                    '.'
            }));
    private static final Set<Character> whitespaceCompatible = new HashSet<>(
            Arrays.asList(new Character[] { '(', '\"' }));

    public Lexer(String src) {
        this.src = src;
        this.cursor = 0;
    }

    public Character grab() {
        return src.charAt(cursor++);
    }

    public List<Character> grabN(int n) {
        List<Character> out = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            out.add(grab());
        }
        return out;
    }

    public boolean hasNext() {
        return cursor < src.length();
    }

    public boolean rangeCheck(int n) {
        return n < src.length();
    }

    private int cursor() {
        return cursor;
    }

    public List<Token> lex() {
        List<Token> tokens = new ArrayList<>();

        Map<String, Token> possibleMatches = new HashMap<String, Token>();
        String builtString;
        Token next;
        String max;
        int j;
        while (hasNext()) {

            // Assemble possible tokens that begin with src.charAt(i):
            builtString = "";
            possibleMatches.clear();
            j = cursor();
            while (rangeCheck(j)) {
                /*
                 * Break inner loop upon reaching whitespace
                 * when not building a token that can contain
                 * whitespace
                 */
                if (builtString.length() > 0
                        && whitespace.contains(src.charAt(j))
                        && !whitespaceCompatible.contains(builtString.charAt(0))) {
                    break;
                }
                builtString += src.charAt(j);
                next = resolve(builtString);
                if (next != null) {
                    possibleMatches.put(builtString, next);
                }
                j++;
            }
            if (possibleMatches.size() > 0) {
                // Add the longest possible token to the output list:
                max = Collections.max(
                        possibleMatches.keySet(),
                        (first, second) -> (first.length() - second.length()));
                // Exclude comments
                Token maxToken = possibleMatches.get(max);
                if (maxToken.type() != TokenType.COMMENT) {
                    tokens.add(maxToken);
                }
                grabN(max.length());
            } else {
                grab();
            }
        }
        return tokens;
    }

    public static Token resolve(String s) {
        // punc
        if (s.length() == 1 && punctuation.contains(s.charAt(0))) {
            return new Token(TokenType.PUNC, s);
        }
        // comment
        if (s.charAt(0) == '(' && s.charAt(s.length() - 1) == ')') {
            int i = 1;
            int nestingLevel = 0;
            char current;
            while (i < s.length() - 1) {
                current = s.charAt(i);
                if (current == ')') {
                    nestingLevel--;
                } else if (current == '(') {
                    nestingLevel++;
                }
                if (nestingLevel < 0) {
                    break;
                }
                i++;
            }
            if (nestingLevel == 0) {
                return new Token(TokenType.COMMENT, null);
            }
        }
        // int lit
        try {
            return new Token(TokenType.LIT, Long.valueOf(s));
        } catch (NumberFormatException e) {
        }
        // id
        {
            boolean isIdentifier = true;

            int i = 0;
            char c;
            while (i < s.length() && isIdentifier) {
                // System.out.println("Running resolve loop on '" + s + "'");
                c = s.charAt(i);
                if (whitespace.contains(c)
                        || punctuation.contains(c)) {
                    isIdentifier = false;
                }
                i++;
            }
            if (isIdentifier) {
                return new Token(s);
            }
        }
        return null;
    }
}

enum TokenType {
    COMMENT,
    ID,
    LIT,
    PUNC;
}

record Token(TokenType type, Object value) {
    public Token(String value) {
        this(TokenType.ID, value);
    }

    public String simpleName() {
        return this.value.toString();
    }

    public String toString() {
        return this.type.toString() + " " + this.value.toString();
    }
}

record Value(MesoType type, Object value) implements MesoValue {
    public Value(Object value) {
        this(predictType(value), value);
    }

    private static MesoType predictType(Object v) {
        Class<?> cls = v.getClass();
        if (TypeMap.MAP.typeMap().keySet().contains(cls)) {
            return TypeMap.MAP.typeMap().get(cls);
        }
        throw new IllegalArgumentException("Could not guess type of value; try specifying it:\n" + v);
    }

    public String toString() {
        if (type == TypeConstants.NAME) {
            return "\'" + value.toString();
        }
        return value.toString()
                // Don't print the type in the case of Singletons;
                // a Singleton's type is the same as its value
                + (this.type != this.value ? " (" + this.type + ")" : "");
    }
}

/*
 * Copyright 2025 Iraxon; this file is free software under the GNU GPL v3-or-later
 */

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Scanner;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;

public class OldMetasulfate {

    private final boolean verbose;
    private final Scope globalScope;

    private OldMetasulfate(boolean verbose, Scope scope) {
        this.verbose = verbose;
        this.globalScope = scope;
    }

    public OldMetasulfate(boolean verbose) {
        this(verbose, Scope.defaultScope);
    }

    public OldMetasulfate() {
        this(false);
    }

    public OldMetasulfate with(String name, Function<MesoValue, MesoValue> func) {
        return new OldMetasulfate(this.verbose, this.globalScope.extend(name, new JavaClosure(func)));
    }

    public OldMetasulfate with(String name, BiFunction<MesoValue, MesoValue, MesoValue> func) {
        return new OldMetasulfate(this.verbose, this.globalScope.extend(name, new JavaClosure(func)));
    }

    /*
     * public static void main(String[] args) throws MetasulfateException {
     * if (args.length != 1) {
     * throw new IllegalArgumentException(
     * "Incorrect number of arguments to Metasulfate interpreter call:\n" +
     * args.length);
     * }
     * new Metasulfate().eval(args[0]);
     * }
     */

    public MesoValue eval(String src) throws MetasulfateException
    /**
     * Interprets raw Metasulfate source
     */
    {
        try {
            if (verbose) {
                System.out.println("Source:\n" + src);
            }
            return new Interpreter(src).nextAndLast();
        } catch (InternalMesoException e) {
            throw new MetasulfateException(e);
        }
    }

    public MesoValue evalFile(String path) throws FileNotFoundException, MetasulfateException {
        String src = "";
        Scanner s = new Scanner(new File(path));
        while (s.hasNextLine()) {
            src += s.nextLine();
        }
        s.close();

        return eval(src);
    }
}

class Interpreter extends Traverser<String, MesoValue> {
    private Scope currentScope;

    public Interpreter(String rawSrc, Scope scope) {
        super(lex(rawSrc));
        this.currentScope = scope;
    }

    public Interpreter(String rawSrc) {
        this(rawSrc, Scope.defaultScope);
    }

    @Override
    public MesoValue next() {
        String t = grab();
        MesoValue rVal;
        switch (t) {
            case "LAMBDA_DOT":
                rVal = new MesoClosure((MesoQuotation) next(), currentScope);
                break;
            case "LET":
                MesoValue next = next();
                String name;
                try {
                    name = ((Name) next).t();
                } catch (ClassCastException e) {
                    throw new TypeException("Non-name object passed to LET:\n" + next);
                }
                currentScope = currentScope.extend(name, next());
                rVal = next();
                currentScope = currentScope.outer();
                break;
            case "\'":
                rVal = new Name(grab());
                break;
            case ".":
                rVal = Singleton.NO_APPLY;
                break;
            case "[":
                String codeString = "";
                for (String part : grabDelimitedRange(t, "]")) {
                    codeString += (part + " ");
                }
                rVal = new MesoQuotation(codeString);
                break;
            default:
                try {
                    rVal = new MesoInt(Long.valueOf(t));
                } catch (NumberFormatException e) {
                    rVal = currentScope.get(t);
                    if (rVal == Singleton.UNDECLARED) {
                        throw new UndefinedNameException("Undefined name:\n" + t);
                    }
                }
                break;
        }
        MesoValue arg = null;
        while (rVal.type().compatibleUnder(TypeConstants.FUNCTION) && (arg != Singleton.NO_APPLY)) {
            System.out.print("Applying:\n" + rVal + "\nto:\n");
            arg = next();
            System.out.println(arg);
                rVal = ((Closure) rVal).apply(next());
        }
        System.out.println("Parser returning:\n" + rVal);
        return rVal;
    }

    // Lexer stuff:

    private static final Set<Character> punctuation = new HashSet<>(
            Arrays.asList(new Character[] {
                    '[', ']',
                    '(', ')',
                    '{', '}',
                    ':', ';',
                    '\'', '\"',
                    '.'
            }));
    private static final Set<Character> whitespaceCompatible = new HashSet<>(
            Arrays.asList(new Character[] { '(', '\"' }));

    public static List<String> lex(String rawSrc) {
        final List<String> rVal = new ArrayList<>();
        lexRec(rVal, rawSrc, "", 0);
        System.out.println("Lexer returning:\n" + rVal);
        return rVal;
    }

    private static void lexRec(List<String> list, String src, String acc, int cursor) {
        Consumer<String> add = (s) -> {
            if (s.length() > 0) {
                list.add(s);
            }
        };
        char current;
        int len = src.length();
        for (cursor = 0; cursor < len; cursor++) {
            current = src.charAt(cursor);
            if (Character.isWhitespace(current)) {
                if (acc.length() > 0 && whitespaceCompatible.contains(acc.charAt(0))) {
                    acc += current;
                } else {
                    add.accept(acc);
                    acc = "";
                }
            } else if (punctuation.contains(current)) {
                add.accept(acc);
                add.accept("" + current);
                acc = "";
            } else {
                if (cursor + 1 >= src.length()) {
                    add.accept(acc + current);
                }
                acc += current;
            }
        }
    }
}

enum TypeMap {
    MAP(genMap());

    private TypeMap(Map<Class<?>, MesoType> typeMap) {
        this.typeMap = typeMap;
    }

    private final Map<Class<?>, MesoType> typeMap;

    private static Map<Class<?>, MesoType> genMap() {
        final Map<Class<?>, MesoType> typeMap = new HashMap<Class<?>, MesoType>();
        typeMap.put(Boolean.class, TypeConstants.BOOLEAN);
        typeMap.put(Class.class, TypeConstants.CLASS);
        typeMap.put(Function.class, TypeConstants.FUNCTION);
        typeMap.put(Long.class, TypeConstants.INT);
        return typeMap;
    }

    public Map<Class<?>, MesoType> typeMap() {
        return this.typeMap;
    }
}

interface MesoType {

    /*
     * Returns whether this type is equivalent to or a subtype of the other type
     */
    public default boolean compatibleUnder(MesoType other) {
        return this == other || other == TypeConstants.OBJECT; // Intentional reference comparisons
    }
}

enum TypeConstants implements MesoType {
    BOOLEAN,
    CLASS,
    DYNAMIC,
    FUNCTION,
    INT,
    QUOTATION,
    NAME,
    OBJECT,
    // Singletons like NO_APPLY are their own types; as such, they are not listed
    // here

    /*
     * Special type to mark types that are unknown until evaluation; it should never
     * appear after evaluation.
     */
    UNKNOWN;

    public String toString() {
        switch (this) {
            case BOOLEAN:
                return "bool";
            case CLASS:
                return "cls";
            case DYNAMIC:
                return "any";
            case FUNCTION:
                return "func";
            case OBJECT:
                return "obj";
            default:
                return this.name().toLowerCase(Locale.ROOT);
        }
    }
}

record MesoClass(MesoType superclass) implements MesoType, MesoValue {
    public MesoType type() {
        return TypeConstants.CLASS;
    }

    @Override
    public boolean compatibleUnder(MesoType other) {
        if (MesoType.super.compatibleUnder(other)) {
            return true;
        }
        return superclass.compatibleUnder(other);
    }
}

enum Singleton implements MesoValue, MesoType {
    NO_APPLY,
    UNDECLARED;

    public String toString() {
        switch (this) {
            case NO_APPLY:
                return ".";
            case UNDECLARED:
                return "!! UNDECLARED !!";
            default:
                throw new IllegalArgumentException(
                        "Missing case statement for " + this + " in Singleton toString() method");
        }
    }

    public MesoType type() {
        return this;
    }
}

enum MesoBoolean implements MesoValue {
    T,
    F;

    public MesoType type() {
        return TypeConstants.BOOLEAN;
    }

    public String toString() {
        switch (this) {
            case T:
                return "T";
            case F:
                return "F";
            default:
                throw new IllegalArgumentException("Impossible Boolean");
        }
    }
}

interface MesoValue {

    public default Object value() {
        throw new TypeException("Attempted to get literal value of complex terminal node:\n" + this);
    }

    public MesoType type();
}

record Name(String t) implements MesoValue {

    public Name {
        if (t == null) {
            throw new NullPointerException("Name cannot be constructed from null");
        }
    }

    @Override
    public MesoType type() {
        return TypeConstants.NAME;
    }

    public String toString() {
        return this.t;
    }
}

interface SimpleValue<T> extends MesoValue {
    @Override
    public T value();

    public default String render() {
        return this.value().toString() + " (" + this.type().toString() + ")";
    }

    public default String typeString() {
        return (this.type() != this.value() ? " (" + this.type() + ")" : "");
    }

    public String toString();
}

record MesoInt(Long value) implements SimpleValue<Long> {
    public Long value() {
        return value;
    }

    public MesoType type() {
        return TypeConstants.INT;
    }

    public MesoValue plus(MesoValue other) {
        try {
            return new MesoInt(this.value + (Long) other.value());
        } catch (ClassCastException e) {
            throw new TypeException("Attempted to add:\n" + this + "\nand:\n" + other);
        }
    }

    public MesoValue multiply(MesoValue other) {
        try {
            return new MesoInt(this.value * (Long) other.value());
        } catch (ClassCastException e) {
            throw new TypeException("Attempted to multiply:\n" + this + "\nand:\n" + other);
        }
    }
}

record Scope(Scope outer, String key, MesoValue value) {

    private static final Scope coreScope = new Scope(
            null, "T", MesoBoolean.T)
            .extend("F", MesoBoolean.F)
            .extend(".", Singleton.NO_APPLY);

    public static final Scope defaultScope = coreScope
            .extend("SUM", new JavaClosure((arg1, arg2) -> (((MesoInt) arg1).plus(arg2))))
            .extend("PRODUCT", new JavaClosure((arg1, arg2) -> (((MesoInt) arg1).multiply(arg2))));

    public Scope extend(String key, MesoValue value) {
        return new Scope(this, key, value);
    }

    public MesoValue get(String k) {
        return k.equals(key) ? value
                : (outer != null ? outer.get(k)
                        : Singleton.UNDECLARED);
    }

    public String toString() {
        String out = "(Env: {";
        Scope current = this;
        while (current.outer != null && !current.equals(defaultScope)) {
            out += current.key + " == " + current.value + "; ";
            current = current.outer;
        }
        return out + "})";
    }
}

record MesoQuotation(String code) implements MesoValue {

    @Override
    public MesoType type() {
        return TypeConstants.QUOTATION;
    }

    public MesoValue run(Scope scope) {
        return new Interpreter(code, scope).nextAndLast();
    }

    public String toString() {
        return "[" + this.code + "]";
    }
}

interface Closure extends MesoValue {

    public MesoValue apply(MesoValue arg);

    @Override
    public default MesoType type() {
        return TypeConstants.FUNCTION;
    }
}

record MesoClosure(MesoQuotation def, Scope env) implements Closure {

    public MesoClosure(String src, Scope env) {
        this((MesoQuotation) new Interpreter(src).nextAndLast(), env);
    }

    @Override
    public MesoValue apply(MesoValue arg) {
        return def.run(env.extend("DOT", arg));
    }

    public String toString() {
        return def.toString() + " " + env.toString();
    }
}

record JavaClosure(Function<MesoValue, MesoValue> func) implements Closure {

    public JavaClosure(BiFunction<MesoValue, MesoValue, MesoValue> biFunc) {
        this(node1 -> new JavaClosure(node2 -> biFunc.apply(node1, node2)));
    }

    @Override
    public MesoValue apply(MesoValue arg) {
        return func.apply(arg);
    }

    public String toString() {
        return "<Java Function>";
    }
}

class MetasulfateException extends Exception {
    public MetasulfateException(InternalMesoException e) {
        super(e.getMessage());
    }
}

class InternalMesoException extends RuntimeException {
    public InternalMesoException(String s) {
        super(s);
    }
}

class EmptySrcException extends InternalMesoException {
    public EmptySrcException(String s) {
        super(s);
    }
}

class TrailingDataException extends InternalMesoException {
    public TrailingDataException(String s) {
        super(s);
    }
}

class UndefinedNameException extends InternalMesoException {
    public UndefinedNameException(String s) {
        super(s);
    }
}

class NoProvidedArgumentException extends InternalMesoException {
    public NoProvidedArgumentException(String s) {
        super(s);
    }
}

class TypeException extends InternalMesoException {
    public TypeException(String s) {
        super(s);
    }
}

class TraverserOutOfItemsException extends NoSuchElementException {
    public TraverserOutOfItemsException(String s) {
        super(s);
    }
}

abstract class Traverser<SrcType, OutputType> {
    private final ListIterator<SrcType> src;
    private Class<?> srcType;
    private final int size;

    public Traverser(List<SrcType> rawSrc) {
        this.size = rawSrc.size();
        if (size <= 0) {
            throw new EmptySrcException("Provided list is empty");
        }
        this.srcType = rawSrc.get(0).getClass();
        this.src = rawSrc.listIterator();
    }

    public abstract OutputType next();

    public OutputType nextAndLast() {
        OutputType rVal = next();
        if (hasNext()) {
            throw new TrailingDataException("Call to nextAndLast did not consume all items, returned:\n" + rVal);
        }
        return rVal;
    }

    protected boolean hasNext() {
        return src.hasNext();
    }

    protected boolean rangeCheck(int externalCursor) {
        if (externalCursor < 0) {
            throw new IndexOutOfBoundsException("Cursor is negative");
        }
        return externalCursor < size();
    }

    public int size() {
        return this.size;
    }

    /*
     * Returns the input item at the cursor position and increments the cursor
     */
    protected SrcType grab() {
        SrcType t = src.next();
        if (true) {
            System.out.println("Grabbing " + srcType.getSimpleName() + ": " + t);
        }
        return t;
    }

    protected List<SrcType> grabN(int n) {
        List<SrcType> rval = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            rval.add(grab());
        }
        return rval;
    }

    /*
     * Continuously grabs input items until reaching a terminator;
     * the terminator is consumed but not returned;
     * if the initiator is not null, then
     * count will be kept to allow for nesting
     */
    protected List<SrcType> grabDelimitedRange(SrcType initiator, SrcType terminator) {
        int nestingLevel = 1; // There was a starting opening brace
        List<SrcType> rval = new ArrayList<>();
        SrcType current;
        while (true) {
            if (true) {
                System.out.print("While looking for " + terminator + ", ");
            }
            current = grab();
            if (current.equals(initiator)) {
                nestingLevel++;
            } else if (current.equals(terminator)) {
                nestingLevel--;
            }
            if (nestingLevel < 1) {
                return rval;
            }
            rval.add(current);
        }
    }
}

import java.io.FileNotFoundException;

public class Main {
    public static void main(String[] args) throws FileNotFoundException, MetasulfateException {

        OldMetasulfate interpreter = new OldMetasulfate(true);

        System.out.println("\n---\n" + interpreter.eval("LAMBDA_DOT [PRODUCT DOT 2] 2") + "\n---\n");

        //System.out.println("\n---\n" + interpreter.evalFile("!standard_library.meso"));
        /*
         * TEST PROGRAMS:
         * LAMBDA_DOT [PRODUCT DOT 2] LET 'x 3 LET 'y 2 SUM x y
         * == 10
         *
         * "LAMBDA_DOT [LET 'x DOT LAMBDA_DOT [SUM x DOT] .] 1 .
         */
    }
}
